---
description: Guidelines for testing Solidity smart contracts
globs: 
alwaysApply: false
---
# Solidity Testing Guidelines

This document outlines the recommended practices for testing Solidity smart contracts within this project, combining insights from our system architecture documentation and established industry best practices like the Coinbase Solidity Style Guide.

## 1. Framework and Tooling

- **Forge:** We use [Forge](mdc:https:/github.com/foundry-rs/foundry/tree/master/crates/forge) for testing and dependency management.

## 2. Testing Strategy

Our testing approach employs a comprehensive strategy that includes unit testing, integration testing, fuzz testing, and invariant testing. We use the Branching Tree Technique (BTT) to structure our concrete tests and ensure thorough coverage.

### 2.1 Directory Structure

Tests should be organized logically within the `test/` directory:

- **Unit Tests:**
    - Concrete: `test/unit/concrete/` (Use BTT `.tree` files here)
    - Fuzz: `test/unit/fuzz/`
- **Integration Tests:**
    - Concrete: `test/integration/concrete/` (Use BTT `.tree` files here)
    - Fuzz: `test/integration/fuzz/`
- **Invariant Tests:** `test/invariant/`
- **Fork Tests:** Can reside within unit/integration directories or dedicated `test/fork/` directories.
- **Helpers/Mocks:** `test/utils/`, `test/mocks/`

### 2.2 File and Contract Naming

- **Test Files:** Follow Solidity style guide conventions and end with `.t.sol`. (e.g., `MyContract.t.sol`, `MyContract.deposits.t.sol`).
- **Test Contracts:** Include the name of the contract or function being tested, followed by "Test". (e.g., `MyContractTest`, `TransferTest`).

### 2.3 Test Function Naming

Use the convention `test[_Fuzz | _Fork | _Revert[If|When]_Condition]_functionName_outcome[_optionalContext]`. Combine prefixes alphabetically (e.g., `testForkFuzz_`).

Examples:

- `test_transfer_updatesBalances()`
- `testFuzz_deposit_handlesDifferentAmounts(uint256 amount)`
- `test_RevertWhen_transferAmountExceedsBalance()`
- `testFork_interaction_correctlyCalculatesReward()`

### 2.4 Test Organization

- **Structure:** Prefer organizing tests by feature/function within a single test contract per contract-under-test (e.g., `MyContractTest` contains all tests for `MyContract`). Alternatively, for very large contracts, grouping tests by function into separate test contracts (`TransferTest`, `DepositTest`) is acceptable.
- **Order:** Test functions within a file should ideally follow the order of functions in the contract-under-test.
- **Focus:** Each test function should ideally test *one specific thing*. Avoid multiple unrelated assertions within a single test. This aids debugging.

YES:

```solidity
function test_transfer_updatesSenderBalance() { ... }
function test_transfer_updatesReceiverBalance() { ... }
function test_transfer_emitsTransferEvent() { ... }
```

NO:

```solidity
function test_transfer() {
  // check sender balance
  // check receiver balance
  // check event emission
}
```

### 2.5 Variables and Assertions

- **Use Variables:** Use named variables for important constants or inputs in tests instead of magic numbers.
- **Assertion Messages:** Use the optional string parameter in assertions (`assertEq`, `assertTrue`, etc.) to provide context for failures (e.g., `assertEq(balance, expectedBalance, "Balance mismatch after transfer");`).
- **Event Testing:** Prefer `vm.expectEmit(true, true, true, true)` (or the shorthand `vm.expectEmit()`) to ensure all event parameters (indexed and non-indexed) are checked.

### 2.6 Base Contracts and Utilities

To promote code reuse and maintain consistency across tests, the project utilizes a set of base abstract contracts and utility files located primarily in `test/`:

- **`Base.t.sol` (`Base_Test`)**: The core base contract.
    - Inherits from `forge-std/Test` and essential utilities (`Events`, `Constants`, `Utils`).
    - Provides a common `setUp` function for initializing standard test users (`admin`, `pauser`, `treasury`, etc.) and shared configuration (`Defaults`).
    - Contains the crucial `deployCoreConditionally` function responsible for deploying and configuring the main WalletConnect system contracts (e.g., `WCT`, `L2WCT`, `WalletConnectConfig`, `Staking`, `RewardManager`) and associated mocks (like `MockBridge`) needed for many test scenarios.
    - Includes helper functions like `createUser`.
- **`Integration.t.sol` (`Integration_Test`)**: Inherits from `Base_Test`. Its `setUp` specifically calls `deployCoreConditionally` to ensure the full system is deployed for integration tests.
- **`Invariant.t.sol` (`Invariant_Test`)**: Inherits from `forge-std/StdInvariant` and `Base_Test`. Its `setUp` also calls `deployCoreConditionally` to prepare the environment for invariant testing.
- **`test/utils/Events.sol`**: An abstract contract declaring all system event signatures. Inheriting this allows tests to easily reference expected events.
- **`test/utils/Constants.sol`**: An abstract contract defining global constants (e.g., `MAX_UINT256`, `BRIDGE_ADDRESS`) to avoid magic values.
- **`test/utils/Utils.sol`**: An abstract contract containing shared utility functions (e.g., `resetPrank`, `_timestampToFloorWeek`).

This hierarchical structure (`Base_Test` -> `Integration_Test`/`Invariant_Test`) centralizes setup logic and makes common definitions readily available, allowing individual test files to focus more on specific test logic rather than boilerplate setup.

## 3. Test Types

### 3.1 Unit Testing

- Verify individual function behaviors in isolation.
- Located in `test/unit/`.
- Use concrete tests (structured with BTT `.tree` files in `test/unit/concrete/`) and fuzz tests (`test/unit/fuzz/`).

### 3.2 Integration Testing

- Verify interactions between different contracts or components.
- Located in `test/integration/`.
- Use concrete tests (structured with BTT `.tree` files in `test/integration/concrete/`) and fuzz tests (`test/integration/fuzz/`).

### 3.3 Fuzz Testing

- **Preference:** Prefer fuzz tests over concrete tests where applicable to discover edge cases.
- Provide random inputs to functions.
- Use clear test naming (`testFuzz_...`).

### 3.4 Invariant Testing

- Ensure core system properties hold true under various conditions and sequences of operations.
- Located in `test/invariant/`.
- Use handlers and stateful fuzzing.
- Write descriptive assertion messages for invariants (e.g., `assertEq(totalDeposits, contractBalance, "Invariant: Sum of deposits must equal contract balance");`).

## 4. Branching Tree Technique (BTT) Specification

The Branching Tree Technique (BTT) uses `.tree` specification files to describe test scenarios. These specifications can be used to scaffold Solidity test files.

This section describes the current interpretation of the `.tree` specification.

### Terminology

- **Condition:** `when`/`given` branches of a tree.
- **Action:** `it` branches of a tree.
- **Action Description:** Children of an action.

### Spec

Each `.tree` file should describe at least one function under test. Trees follow these rules:

- The first line is the root tree identifier, composed of the contract and function names which should be delimited by a double colon (e.g., `ContractName::functionName`).
- The `.tree` format uses `├` and `└` characters to denote branches.
- If a branch starts with either `when` or `given`, it is a **Condition**. Use `given` for contract states prepared in advance (preconditions) and `when` for modes of execution or user-controlled function parameters.
- If a branch starts with `it`, it is an **Action**.
- Any child branch an action has is called an **Action Description**.
- Keywords (`when`, `given`, `it`) are case-insensitive.
- Anything starting with a `//` is a comment and will be ignored during processing.
- Multiple trees can be defined in the same file to describe different functions by following the same rules, separating them with two newlines.

Take the following Solidity function:

```solidity
function hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {
    return a < b ? hash(a, b) : hash(b, a);
}
```

A reasonable `.tree` specification for the above function would be:

```
HashPairTest::hashPair // Root Identifier: Contract::function
├── It should never revert. // Top-level Action
├── When first arg is smaller than second arg // Condition
│   └── It should match the result of `keccak256(abi.encodePacked(a,b))`. // Action
└── When first arg is bigger than second arg // Condition
    └── It should match the result of `keccak256(abi.encodePacked(b,a))`. // Action
```

There is a top-level action that describes an invariant test (it should never revert). Then, two condition branches (`a < b` and `a >= b`) each end in an action describing the expected outcome, which will result in the generation of the respective test scaffolds.

Note the following things:

- **Syntax:** Actions (`it` branches) often end with punctuation (like a period), while conditions (`when`/`given` branches) typically do not. This is because conditions are often transformed into modifiers or function name components and must be valid Solidity identifiers. Action descriptions can contain more free-form text.
- **Structure:** You can have top-level actions without conditions. Actions with sibling conditions are also supported.
- **Naming:** The contract part of the root identifier (e.g., `HashPairTest`) is typically used as the base name for the generated test contract.

Suppose you have additional Solidity functions (`min`, `max`) to test within the same logical contract scope, say `Utils`:

```solidity
function min(uint256 a, uint256 b) private pure returns (uint256) {
    return a < b ? a : b;
}

function max(uint256 a, uint256 b) private pure returns (uint256) {
    return a > b ? a : b;
}
```

The full `.tree` spec for all three functions (`hashPair`, `min`, `max`) within the `Utils` scope would be:

```
Utils::hashPair
├── It should never revert.
├── When first arg is smaller than second arg
│   └── It should match the result of `keccak256(abi.encodePacked(a,b))`.
└── When first arg is bigger than second arg
    └── It should match the result of `keccak256(abi.encodePacked(b,a))`.


Utils::min
├── It should never revert.
├── When first arg is smaller than second arg
│   └── It should match the value of `a`.
└── When first arg is bigger than second arg
    └── It should match the value of `b`.


Utils::max
├── It should never revert.
├── When first arg is smaller than second arg
│   └── It should match the value of `b`.
└── When first arg is bigger than second arg
    └── It should match the value of `a`.
```

Note the following things:

- **Consistency:** Contract identifiers (e.g., `Utils`) must be present and consistent across all root identifiers within a single `.tree` file intended for one test contract. Mismatched identifiers can cause errors during processing and must be manually corrected.
- **Deduplication:** Duplicate conditions defined across separate trees within the same file may be deduplicated when transformed into Solidity modifiers during scaffolding.
- **Test Naming:** The function part of the root identifier for each tree (e.g., `min`, `max`) will typically be emitted as part of the generated Solidity test function name (e.g., `test_Min_ShouldNeverRevert`).

### Generated Output Considerations

When scaffolding tests from `.tree` specifications, keep in mind:

- **Filename:** The generated Solidity test contract filename typically corresponds to the `.tree` filename but with a `.t.sol` extension (e.g., `utils.tree` scaffolds to `utils.t.sol`).
- **Order:** Tests are generally emitted in the order their corresponding actions appear in the `.tree` file.
- **Modifiers:** One modifier may be generated per unique condition branch path, often excluding leaf condition nodes.
- **Naming Convention:** Generated test function names should follow the project's naming conventions (as described in @Test Function Naming).

## 5. Fork Testing

- **Usage:** Use liberally to test interactions with existing deployed contracts instead of relying solely on mocks.
- **Configuration:**
    - Define RPC endpoints in `foundry.toml` under `[rpc_endpoints]`.
    - Use Forge's cheatcodes (`vm.createSelectFork`) in tests.
    - Access RPC URLs via `stdChains` (e.g., `vm.createSelectFork(stdChains.mainnet.rpcUrl)`).
    - **Always pin to a specific block number** (`vm.createSelectFork(rpcUrl, blockNumber)`) for determinism and RPC caching. Avoid the `--fork-url` CLI flag.
- **Caching:** Forge caches RPC calls when a block number is pinned, making subsequent runs much faster.
- **Fuzzing on Forks:** Be mindful of RPC rate limits when fuzzing on forks if inputs affect RPC calls. Consider using seeds (`--fuzz-seed`), multicall, or structuring tests to minimize RPC calls based on fuzzed inputs.

## 6. Test Harnesses

- **Internal Functions:** To test internal functions, create a harness contract that inherits from the contract-under-test (CuT) and exposes the internal function via a public/external wrapper function named `exposed_<internalFunctionName>`.
- **Private Functions:** Private functions are difficult to test directly. Consider making them internal if feasible or accept the limitation.
- **Workaround Functions:** Harnesses can also add "workaround" functions (e.g., `workaround_getQueueLength()`) to expose state or data useful for testing (like array lengths or internal counters) that isn't available via the public interface. These can also be used for "ghost variables" in invariant testing.
